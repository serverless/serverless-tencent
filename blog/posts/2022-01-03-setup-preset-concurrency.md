---
title: 如何快速为腾讯云云函数配置合适的预置并发数量
description: 可以在腾讯云使用基于云函数自身的并发请求数据，快速为云函数计算出一个合适的预置并发配置的数量
date: 2022-01-03
layout: Post
thumbnail: https://sp-assets-1300963013.file.myqcloud.com/blog/thumbnails/2022-01-03-setup-preset-concurrency.png
authors:
  - ZongMeng
category:
  - guides-and-tutorials
---

本文主要内容：

1. 什么是云函数预置并发？为什么要设置预置并发？
2. 设置预置并发的原则是什么？
3. 设置预置并发可以达到的预期是什么？
4. 如何使用本文提供的计算脚本快速计算出合适的预置并发数量

## 什么是云函数预置并发？ 为什么要设置预置并发？

### 什么是云函数预置并发?

腾讯云云函数预置并发功能是腾讯云提供的一种基于版本纬度上支持并发实例按照配置预先启动，防止云函数平台主动回收实例，尽可能保证当有并发请求来临时有对应数量的实例可以进行请求处理的功能。[官方详细文档](https://cloud.tencent.com/document/product/583/46743#.E6.A6.82.E8.BF.B0)

### 为什么要设置预置并发?

1. 预置并发可以保持函数的存活，不主动被云函数平台回收，保证可以快速的处理请求
2. 可预先进行计算资源的准备， 降低冷启动、运行环境初始化以及业务代码初始化引起的耗时

## 设置预置并发的原则

1. 设置适合云函数请求量的预置并发数量。
   云函数配置了预置并发之后，没有被请求使用到的预置并发被称为**闲置预置并发**。预置并发会对限制预置并发实例进行费用收取，对使用中的实例进行弹性收费。所以说如果我们配置了大量的预置并发，但是云函数实际的并发请求量并不大，那我们会产生大量的**闲置预置并发费用**。可以参考腾讯云官方的[计费示例](https://cloud.tencent.com/document/product/583/12285#.E9.A2.84.E7.BD.AE.E5.B9.B6.E5.8F.91.E9.97.B2.E7.BD.AE.E8.B4.B9.E7.94.A8)
2. 如果一个云函数的请求在一天之中的不同时间段内起伏较大，比如工作时间段并发请求量大，在凌晨请求量小。可以考虑使用腾讯云提供的**定时预置**[功能](https://cloud.tencent.com/document/product/583/63698), 可以在低请求量的时间段动态调整预置并发数量，减少限制预置并发的费用。
3. 云函数提供了**并发计算器能力**, 但是只能依据**30 分钟**之内的请求量进行动态计算，有一定的局限性。

## 设置预置并发的预期效果是什么？

1. 减少因为云函数冷启动问题带来的请求失败，请求耗时过长的问题
2. 不会产生过多的**闲置预置并发**费用，可以动态的为云函数配置一个相对合理的预置并发数量

## 使用**Analytics-concurrency**计算脚本为云函数快速计算相对合适的预置并发数量

因为云函数提供了**定时预置并发**功能， 可以更加灵活的为不同时间段的请求动态设置预置并发，减少了闲置预置并发的费用。为了帮助用户得到云函数的一个相对合理的预置并发数量的配置，提供了方便的计算脚本: [Analytics-concurrency](https://github.com/serverless-components/Analytics-concurrency). 使用此脚本，用户只需要对基本的数据资料进行填充，即可得到一个基于云函数并发请求量计算出来的**预置并发**的参考配置。 提供了:
1. 基于时间聚合区间的费用计算
2. 基于时间聚合区间的预置并发配置推荐, 用户可以作为云函数**定时预置并发**的参考值
3. 以天为单位的费用总计
4. 基于时间粒度的费用计算

### 脚本使用步骤

1. `git clone git@github.com:serverless-components/Analytics-concurrency.git`
2. 安装依赖: `npm install`
3. 在腾讯云控制台找到想要统计的云函数，通过 **监控信息**可以获取云函数的**并发执行个数和预置并发**此项数据, ![](https://sp-assets-1300963013.file.myqcloud.com/blog/posts/2022-01-03-setup-preset-concurrency-2.jpg)，将 csv 数据下载到此脚本仓库的`resources`(如没有此文件夹，自行创建即可), 注意事项:
   1. 下载的每一天的数据，**必须保证选取的时间范围和时间粒度相同**, 因为我们后面会将每一个文件中处于同一时间粒度(比如`2021-10-10 00:01`, `2021-10-11 00:01`)的数值相加，然后求得所有日期的同一时间粒度的平均数。
   2. 下载的 csv 文件建议使用*日期+函数名*命名
4. 将所需云函数的 csv 监控数据下载在 **resources** 文件夹之后，执行`npm run build:data`, 执行成功之后，会在根目录生成 `data.json` 文件，包含了对`resources`下的源数据分析:

```json
{
  "date": [..., "2020-01-01 01:01", "2020-01-01 01:02",...],
  "data": [..., 3, 2, ...]
}
```

    1. `date`: 根据源数据中的时间及其粒度自动生成的日期数据， 其中 **年-月-日**字段是为了后面的图表而根据运行脚本的时刻自动生成的填充数据，没有实际意义. 上面的例子表示的基于**1分钟**为时间粒度生成的日期数据.
    2. `data`: 根据每一天的源数据中的**并发执行个数**数据，自动计算得到。比如现在有两个源文件: `scf-2022-01-01.csv, scf-2022-01-02.csv`, 会把这两个文件中同一时间粒度(`01:01, 01:02`)的并发执行个数计算得到一个平均数值. 上面的例子表示这两个csv文件中 **01:01**时刻的并发执行个数的平均值是 **3**, **01:02** 时刻是 **2**.
    3. 需要对 `data.json` 中生成的数据进行数据可视化，进而确定要统计的时间区间， 我们这里以`Echarts`图形库为例, 用户可自行选择合适的工具:
    4. 打开[Echarts 在线编辑器](https://echarts.apache.org/examples/zh/editor.html?c=line-sections)
    5. 将如下内容复制到编辑框中:

```javascript
option = {
  dataZoom: {},
  tooltip: {
    trigger: 'axis',
    axisPointer: {
      type: 'cross',
    },
  },

  xAxis: {
    type: 'category',
    boundaryGap: false,
    // prettier-ignore
    data: [],
  },
  yAxis: {
    type: 'value',
    axisLabel: {
      formatter: '{value}',
    },
    axisPointer: {
      snap: true,
    },
  },
  series: [
    {
      type: 'line',
      smooth: true,
      // prettier-ignore
      data: [],
    },
  ],
};
```

4. `data.json`数据中的`date` 数据放置在上面数据结构的`xAxis->data`中，`data`数据放置在`series->data` 中，生成完整的可视化图表，观察数据走势，如果从某个时刻开始并发请求量大幅增加或者减少， 那么可能就是一个需要进行数据聚合的时间段, 因为不同时间段的的并发请求量差距较大，需要分别设置不同的预置并发才能满足请求流量。最终划分出多个时间区间. 

本文提到的**时间聚合区间** 就是指的在这一步观察出来的不同的时间段，而有了**时间聚合区间**之后我们才有了设置**定时预置**的基础,因为定时预置的前提就是**在不同的时间段中，设置不同的预置并发数量**

5. 将生成的数据划分区间填充在`timeRange.json`文件中:

```json
[
  ["00:00", "02:00"],
  ["02:01", "08:59"],
  ["09:00", "23:59"]
]
```

上面的例子表示将以天为单位的时间粒度划分出 3 个时间聚合区间来对应不同时间段的并发请求数量的变化.

6. 执行`npm run build:result` 生成预置并发预测数据: `result.json`:

   1. `costTotal`: 代表一天中总的闲置预置并发的费用
   2. `plan`:
   3. `time`: 表示需要配置预置并发的时间区间
   4. `count`: 表示在`time` 时间设置的预置并发数量
   5. `itemCostTotal`: 表示在`time` 区间的的闲置预置并发费用
   6. `cost` 中的每一项代表在当前时间粒度中发生的**并发请求数量**以及对应的**闲置预置并发费用**.
   7. 根据`result.json` 生成的结果数据，用户可以自行在腾讯云控制台上配置云函数所需要的预置并发数量

```json
{
  "costTotal": "1.2",
  "plan": [{
    "time": ["00:00", "02:00"],
    "count": 1,
    "itemCostTotal": 0.3,
    "cost": [
        {
          "time": "2022-01-05 0:0",
          "concurrency": 2,
          "itemCost": 0
        }
    ],
    "...."
  }]
}
```
---
这里有几点脚本的使用注意事项:
1. 脚本会基于用户在`resources` 中填充的 CSV 数据，计算所有数据在同一时间粒度的平均值
2. 用户放置在`resources` 中的 CSV 文件需要使用统一的时间粒度，比如 **1 分钟，5 分钟， 1 小时**
3. 用户可以自行选择可视化工具
4. 最后的费用计算结果保留的**小数点后三位**
5. 此脚本提供的是基于云函数的并发请求量计算出来的客观结果，不保证可靠性和费用的一致性，**仅作为参考使用**。

### 脚本运行流程图

![](https://sp-assets-1300963013.file.myqcloud.com/blog/posts/2022-01-03-setup-preset-concurrency-1.png)
